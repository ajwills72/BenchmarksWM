legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2b")
axis(side=1, at=c(1:2), labels=c("2", "6"))
axis(2) #brings back y-axis
box()   #brings back the frame
x11()
plot.confint(designdat3, c(1,3), c(1,2), -0.04, xlim = c(0.5, 6.5), pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat3, c(2,4), c(1,2), 0.04, xlim = c(0.5, 6.5), pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2c")
axis(side=1, at=c(1:2), labels=c("2", "6"))
axis(2) #brings back y-axis
box()   #brings back the frame
xlimit = c(0.5,2.5)
x11()
par(cex=1.2)
plot.confint(designdat1, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "Search Set Size", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat1, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2a")
axis(side=1, at=c(1:2), labels=c("1", "4"))
axis(2) #brings back y-axis
box()   #brings back the frame
x11()
plot.confint(designdat2, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat2, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2b")
axis(side=1, at=c(1:2), labels=c("2", "6"))
axis(2) #brings back y-axis
box()   #brings back the frame
x11()
plot.confint(designdat3, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat3, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2c")
axis(side=1, at=c(1:2), labels=c("2", "6"))
axis(2) #brings back y-axis
box()   #brings back the frame
xlimit = c(0.5,2.5)
x11()
par(cex=1.3)
plot.confint(designdat1, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "Search Set Size", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat1, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2a")
axis(side=1, at=c(1:2), labels=c("1", "4"))
axis(2) #brings back y-axis
box()   #brings back the frame
x11()
par(cex=1.3)
plot.confint(designdat2, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat2, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2b")
axis(side=1, at=c(1:2), labels=c("2", "6"))
axis(2) #brings back y-axis
box()   #brings back the frame
x11()
par(cex=1.3)
plot.confint(designdat3, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat3, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2c")
axis(side=1, at=c(1:2), labels=c("2", "6"))
axis(2) #brings back y-axis
box()   #brings back the frame
library(lattice)
library(gdata)
library(gtools)
library(gplots)
pt = c(1,17,2,15,0)
# point styles
cl <- c("black", "red", "blue", "green", "magenta")
#convenient for figures for presentations
td <- paste(as.character("C:\\Daten\\R\\models\\CSpan.Opdur.Freetime\\VisualSearch",sep="\\"))
setwd(td)
source("plot.confint.R")
memdat <- read.table("cspanvisualsearch123.memory.dat", header=TRUE, dec=".")
spcdat <- read.table("cspanvisualsearch123.spc.dat", header=TRUE, dec=".")
drtdat <- read.table("cspanvisualsearch123.dist.dat", header=TRUE, dec=".")
#drtdat <- read.table("cspanvisualsearch123.dist.medianRT.dat", header=TRUE, dec=".")
drtspcdat <- read.table("cspanvisualsearch123.distserpos.dat", header=TRUE, dec=".")
### Plot full design for each experiment
# Memory
design1 <- memdat[memdat$experiment==1,3:6]
rmean = rowMeans(design1)
designdat1 <- design1 - rmean + mean(rmean)
design2 <- memdat[memdat$experiment==2,3:6]
rmean = rowMeans(design2)
designdat2 <- design2 - rmean + mean(rmean)
design3 <- memdat[memdat$experiment==3,3:6]
rmean = rowMeans(design3)
designdat3 <- design3 - rmean + mean(rmean)
xlimit = c(0.5,2.5)
x11()
par(cex=1.3)
plot.confint(designdat1, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "Search Set Size", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat1, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2a")
axis(side=1, at=c(1:2), labels=c("1", "4"))
axis(2) #brings back y-axis
box()   #brings back the frame
x11()
par(cex=1.3)
plot.confint(designdat2, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "Search Set Size", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat2, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2b")
axis(side=1, at=c(1:2), labels=c("2", "6"))
axis(2) #brings back y-axis
box()   #brings back the frame
x11()
par(cex=1.3)
plot.confint(designdat3, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "Search Set Size", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat3, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2c")
axis(side=1, at=c(1:2), labels=c("2", "6"))
axis(2) #brings back y-axis
box()   #brings back the frame
x11()
par(cex=1.3)
plot.confint(designdat2, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "Search Set Size", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat2, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.85, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2b")
axis(side=1, at=c(1:2), labels=c("2", "6"))
axis(2) #brings back y-axis
box()   #brings back the frame
x11()
par(cex=1.3)
plot.confint(designdat2, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "Search Set Size", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat2, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.85, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2c")
axis(side=1, at=c(1:2), labels=c("2", "6"))
axis(2) #brings back y-axis
box()   #brings back the frame
x11()
par(cex=1.3)
plot.confint(designdat3, c(1,3), c(1,2), -0.04, xlim = xlimit, pch=21, pt.bg="black", ylim=c(0.5,1), axes=F, xlab = "Search Set Size", ylab = "Proportion correct")
par(new=T)
plot.confint(designdat3, c(2,4), c(1,2), 0.04, xlim = xlimit, pch=22, pt.bg="white", ylim=c(0.5,1), axes=F, xlab = "", ylab = "Proportion correct")
legend(0.7, 0.55, legend=c("long", "short"), pch=c(21,22), pt.bg = c("black", "white"), lty=c(1,1), cex = 0.8, pt.cex=1.0, title = "Free Time", xjust=0, yjust=0)
title("Exp. 2b")
axis(side=1, at=c(1:2), labels=c("2", "6"))
axis(2) #brings back y-axis
box()   #brings back the frame
library(gdata)
library(gtools)
library(gplots)
source("plot.confint.R")
pt = c(1,17,2,15,0)
# point styles
############### Oswi 1 ##################################################
data <- read.table("oswi1.dat", header=TRUE, dec=".")
########Simulate data from a four-accumulator LBA model#######
#set parameter values for the LBA model used to generate the data
n=400; b=400; A=300; v1=c(.9,.75,.6); s=0.25; Ter=300
v2frac=0.5 ; v4frac=0.25 # The fraction of v1 given to wrong stimuli.
#make a matrix into which the data will be inserted
rawdata=matrix(nrow=length(v1)*n,ncol=3)
t1=vector(length=n*length(v1))
t2=vector(length=n*length(v1))
t3=vector(length=n*length(v1))
t4=vector(length=n*length(v1))
t=vector(length=n*length(v1))
for (j in 1:3) {
#the time taken for accumulator i to reach threshold is
#(b-a)/v, where a is a draw from a U(0,A) and v is from N(v1,s)
for (i in 1:n) {
t1[n*(j-1)+i]=(b-runif(1,min=0,max=A))/(rnorm(1,mean=v1[j],sd=s))
t2[n*(j-1)+i]=(b-runif(1,min=0,max=A))/(rnorm(1,mean=(v2frac*v1[j]),sd=s))
t3[n*(j-1)+i]=(b-runif(1,min=0,max=A))/(rnorm(1,mean=(v2frac*v1[j]),sd=s))
t4[n*(j-1)+i]=(b-runif(1,min=0,max=A))/(rnorm(1,mean=(v4frac*v1[j]),sd=s))
}
#sometimes all t values can be negative, this generates another RT for
#those RTs that were negative
temp1=(t1<0)&(t2<0)&(t3<0)&(t4<0)
if (any(temp1)) {
for (i in which(temp1)) {
t1[i]=(b-runif(1,min=0,max=A))/(rnorm(1,mean=v1[j],sd=s))
t2[i]=(b-runif(1,min=0,max=A))/(rnorm(1,mean=(v2frac*v1[j]),sd=s))
t3[i]=(b-runif(1,min=0,max=A))/(rnorm(1,mean=(v2frac*v1[j]),sd=s))
t4[i]=(b-runif(1,min=0,max=A))/(rnorm(1,mean=(v4frac*v1[j]),sd=s))
}
}
}
#any negative ts are made large so that they are not the first accumulator
t1[t1<0]=1e6 ; t2[t2<0]=1e6 ; t3[t3<0]=1e6 ; t4[t4<0]=1e6
#indicator variable which is TRUE when correct accumulator reaches
#threshold before the error accumulator
tmp=vector(length=n*length(v1))
for (i in 1:length(t1)) {
tmp=which.min(c(t1[i],t2[i],t3[i],t4[i]))
#add Ter to ts produced by the LBA
rawdata[i,3]=switch(tmp,t1[i],t2[i],t3[i],t4[i])+Ter
rawdata[i,2]=tmp
}
rawdata[,1]=rep(1:length(v1),each=n)
#write the data into a txt file
write.table(rawdata,file="multidata.txt",row.names=F,col.names=F,sep="\t")
#######Fit the data with a four-accumulator LBA model#######
#define functions needed for fitting
fptcdf=function(z,x0max,chi,driftrate,sddrift) {
zs=z*sddrift ; zu=z*driftrate ; chiminuszu=chi-zu ; xx=chiminuszu-x0max
chizu=chiminuszu/zs ; chizumax=xx/zs
tmp1=zs*(dnorm(chizumax)-dnorm(chizu))
tmp2=xx*pnorm(chizumax)-chiminuszu*pnorm(chizu)
1+(tmp1+tmp2)/x0max
}
fptpdf=function(z,x0max,chi,driftrate,sddrift) {
zs=z*sddrift ; zu=z*driftrate ; chiminuszu=chi-zu
chizu=chiminuszu/zs ; chizumax=(chiminuszu-x0max)/zs
(driftrate*(pnorm(chizu)-pnorm(chizumax)) +
sddrift*(dnorm(chizumax)-dnorm(chizu)))/x0max
}
n1PDF=function(t,x0max,chi,drift,sdI,t0range=NA,nrect=100) {
# Generates defective PDF for responses on node #1.
if (length(t0range)==2) return(n1PDFvart0(t=t,x0max=x0max,chi=chi,
drift=drift,sdI=sdI,mint0=t0range[1],maxt0=t0range[2],nrect=nrect))
N=length(drift) # Number of responses.
if (N>2) {
tmp=array(dim=c(length(t),N-1))
for (i in 2:N) tmp[,i-1]=fptcdf(z=t,x0max=x0max,chi=chi,driftrate=drift[i],sddrift=sdI)
G=apply(1-tmp,1,prod)
} else {
G=1-fptcdf(z=t,x0max=x0max,chi=chi,driftrate=drift[2],sddrift=sdI)
}
G*fptpdf(z=t,x0max=x0max,chi=chi,driftrate=drift[1],sddrift=sdI)
}
obj=function(pars,data) {
#Scott: I fit on log scale.
pars[1:3]=exp(pars[1:3])
ll=matrix(nrow=length(data[,1]))
#loop over the stimuli
for (i in 1:3) {
for (j in 1:4) {
vs=c(pars[4+(i-1)*4],pars[5+(i-1)*4],pars[6+(i-1)*4],pars[7+(i-1)*4])
# ko: extracts the drift rates for the 4 response options in the i conditions from the parameter vector
vs=switch(j,vs,vs[c(2,1,3,4)],vs[c(3,1,2,4)],vs[c(4,1,2,3)])
# ko: picks the j-th vector of the four vs-vectors listed - one for each possible response j (j = 1 is the correct response)
tmp=(data[,2]==j)&(data[,1]==i)
# ko: set to TRUE where the condition = i and the response = j
#use n1PDF to get likelihood values
ll[tmp]=n1PDF(t=data[tmp,3]-pars[2],x0max=pars[1],chi=pars[1]+pars[3],sdI=.25,drift=vs)
# ko: computes likelihood for RT in condition i with response j (selected by tmp), minus Ter (=pars[2]), with parameters A (x0max), b (x0max+chi), standard deviation (sdI) fixed, and drifts of the 4 accumulators (vs), the first of which represents the response given (?)
}
}
# Scott: I put the 'pmax' in here to avoid log(0) problems.
-sum(log(pmax(ll,1e-10)),na.rm=T)
}
#read in data from text file
data=read.table("multidata.txt",header=F)
#Heuristics for generating start-points
I1=matrix(nrow=4,ncol=3)
I1[1,]=qnorm(tapply(data[,2]==1,data[,1],mean),sd=.3*sqrt(2))*2
I1=.5+I1
# ko: start values for the drift rates of the correct response for the conditions specified in data[,1], computed from the means of RTs in data[,3]
I1[2,]=I1[1,]/2; I1[3,]=I1[1,]/2; I1[4,]=I1[1,]/4
# ko: start values for the drift rates of the incorrect responses (2 orthogonal, half as large as correct, and one opposite, 1/4 as large as correct)
Ter=min(data[,3]); Ter=Ter*0.9
x0max=mean(tapply(data[,3],data[,1],quantile,.7)-tapply(data[,3],data[,1],quantile,.3))*2
#Don't directly fit b, but instead b-A.
chi=(.25*x0max)
# ko: start values for Ter, starting point A (x0max) and interval from b to A (chi)
#Fit on log scale.
pars=c(log(c(x0max,Ter,chi)),I1) ; attr(par,"obj")=NA
#set the number of iterations for the SIMPLEX routine
fitnum=c(200,500,2000)
#use optim to maximise the log-likelihood
for (fit in 1:length(fitnum)) {
output=optim(fn=obj,par=pars,data=data,control=list(maxit=fitnum[fit],parscale=pars))
pars=output$par
}
#put the results of the fit into a variable called pars
params=c(exp(pars[1:3]),pars[4:15])
#the fitting function gives back (b-A) instead of b. To make the output look like that given in Brown and Heathcote (2008) we add A to b-A to get b
params[3]=params[3]+params[1]
#give names to the parameters
names(params)=c("A","ter","b","v_e1","v_e2","v_e3","v_e4","v_m1","v_m2","v_m3","v_m4","v_h1","v_h2","v_h3","v_h4")
#print the parameters onscreen
print(params,3)
#Make the histograms
minx=350; maxx=2250; bindiff=100
bins=seq(minx,maxx,bindiff)
x0max=params[1]; chi=params[3]; sdI=.25
#defines the layout of the plots, currently set to make 2 rows of 3 columns
layout(m=matrix(1:12,nrow=4))
for (i in 1:3) {
for (j in 1:4) {
vs=c(pars[4+(i-1)*4],pars[5+(i-1)*4],pars[6+(i-1)*4],pars[7+(i-1)*4])
vs=switch(j,vs,vs[c(2,1,3,4)],vs[c(3,1,2,4)],vs[c(4,1,2,3)])
#use n1PDF to get likelihood values
if (i==1&j==1) title="easy correct" else if (i==1&j==2) title="easy perpendicular error" else if (i==1&j==3) title="easy perpendicular error" else if (i==1&j==4) title="easy opposite error" else if (i==2&j==1) title="medium correct" else if (i==2&j==2) title="medium perpendicular error"  else if (i==2&j==3) title="medium perpendicular error"  else if (i==2&j==4) title="medium opposite error" else if (i==3&j==1) title="hard correct" else if (i==3&j==2) title="hard perpindicular error" else if (i==3&j==3) title="hard perpindicular error" else if (i==3&j==4) title="hard opposite error"
#get the predicted values for each bin
# Get predicted response probability.
pprob = integrate(f=n1PDF,lower=0,upper=Inf,x0max=x0max,chi=chi,drift=vs,sdI=sdI)
histpred=n1PDF(bins-bindiff*0.5-params[2],x0max,chi,vs,sdI)*sum(data[,1]==1)*bindiff
#get the data for the histogram
histdata=data[(data[,3]<maxx)&(data[,1]==i)&(data[,2]==j),3]
#make the histogram for the data
hist(histdata,breaks=bins,freq=T,xlab="RT (ms)", xlim=c(50,quantile(data[,3],.99)),ylim=c(0,max(histpred)+max(histpred)*.5),main=title)
#draw the line representing the predicted values
matpoints(x=bins-bindiff*0.5,y=histpred,type="l",col=2,lty=1,lwd=3)
}
}
truecorr <- 0.5
interaction <- matrix(0,100,1)
prob <- matrix(0,100,1)
for (replic in 1:1000) {
youngpred <- rnorm(150, mean = 0, sd = 2)
oldpred <- rnorm(100, mean=2, sd=2)
youngcrit <- sqrt(1-truecorr)*rnorm(150, mean=0, sd=2) + truecorr*youngpred
oldcrit <- sqrt(1-truecorr)*rnorm(100, mean=0, sd=2) + truecorr*oldpred
dyoung <- as.data.frame(cbind(youngpred, youngcrit))
dold <- as.data.frame(cbind(oldpred, oldcrit))
dyoung <- dyoung[dyoung$youngpred > -2 & dyoung$youngcrit < 2,]   #retriction of range
names(dold) <- c("pred", "crit")
names(dyoung) <- c("pred", "crit")
age <- c(matrix(1, dim(dyoung[1]), 1), matrix(2, 100, 1))
data <- rbind(dyoung, dold)
data <- cbind(age, data)
data <- as.data.frame(data)
m1 <- lm(crit ~ pred+age, data)
m2 <- lm(crit ~pred+age+pred*age, data)
#anova(m1, m2)
beta <- coef(m2)
stats <- summary(m2)
interaction[replic] <- beta[4]
prob[replic] <- stats$coefficients[4,4]
}
x11()
hist(interaction, xlab="B", main="Regression Weight of Interaction Term")
x11()
hist(prob, breaks=20, xlab="P", main="P Value")
sig = prob[prob<0.05]
length(sig)
setwd("C:/Daten/R/Models/LocRec")
#wipe everything
rm(list=ls())
library(lme4)
library(gdata)
library(languageR)
filedir <- paste(as.character("C:\\Daten\\R\\Models\\Locrec",sep="\\"))
setwd(filedir)
#for HY Lin's local-recognition experiment summer 2012
filename <- "MLR.txt"
#for KO's local-recognition experiment in wmc2002 study
#filename <- "locrec2002.txt"
Data <- read.table(filename,header=TRUE,row.names=NULL)
Data$spatialexp <- exp(-Data$SpatialDistance)
Data$temporalexp <- exp(-Data$TemporalDistance)
str(Data)
# analysis of spatial and temporal distance effects for new and intrusion probes in local recognition.
# probetype: 1 = new, 0 = intrusion. Distances for new probes are set to 100.
#wipe everything
rm(list=ls())
library(lme4)
library(gdata)
library(languageR)
filedir <- paste(as.character("C:\\Daten\\R\\Models\\Locrec",sep="\\"))
setwd(filedir)
#for HY Lin's local-recognition experiment summer 2012
#filename <- "MLR.txt"
#for KO's local-recognition experiment in wmc2002 study
filename <- "locrec2002.txt"
Data <- read.table(filename,header=TRUE,row.names=NULL)
Data$spatialexp <- exp(-Data$SpatialDistance)
Data$temporalexp <- exp(-Data$TemporalDistance)
# analysis of spatial and temporal distance effects for new and intrusion probes in local recognition.
# probetype: 1 = new, 0 = intrusion. Distances for new probes are set to 100.
#wipe everything
rm(list=ls())
library(lme4)
library(gdata)
library(languageR)
filedir <- paste(as.character("C:\\Daten\\R\\Models\\Locrec",sep="\\"))
setwd(filedir)
#for HY Lin's local-recognition experiment summer 2012
#filename <- "MLR.txt"
#for KO's local-recognition experiment in wmc2002 study
filename <- "locrec2002.txt"
Data <- read.table(filename,header=TRUE,row.names=NULL)
str(data)
str(Data)
# analysis of spatial and temporal distance effects for new and intrusion probes in local recognition.
# probetype: 1 = new, 0 = intrusion. Distances for new probes are set to 100.
#wipe everything
rm(list=ls())
library(lme4)
library(gdata)
library(languageR)
filedir <- paste(as.character("C:\\Daten\\R\\Models\\Locrec",sep="\\"))
setwd(filedir)
#for HY Lin's local-recognition experiment summer 2012
#filename <- "MLR.txt"
#for KO's local-recognition experiment in wmc2002 study
filename <- "locrec2002.txt"
Data <- read.table(filename,header=TRUE,row.names=NULL)
Data$spatialexp <- exp(-Data$SpatialDistance)
Data$temporalexp <- exp(-Data$TemporalDistance)
str(Data)
# analysis of spatial and temporal distance effects for new and intrusion probes in local recognition.
# probetype: 1 = new, 0 = intrusion. Distances for new probes are set to 100.
#wipe everything
rm(list=ls())
library(lme4)
library(gdata)
library(languageR)
filedir <- paste(as.character("C:\\Daten\\R\\Models\\Locrec",sep="\\"))
setwd(filedir)
#for HY Lin's local-recognition experiment summer 2012
#filename <- "MLR.txt"
#for KO's local-recognition experiment in wmc2002 study
filename <- "locrec2002.txt"
Data <- read.table(filename,header=TRUE,row.names=NULL)
Data$spatialexp <- exp(-Data$SpatialDistance)
Data$temporalexp <- exp(-Data$TemporalDistance)
str(Data)
# analysis of spatial and temporal distance effects for new and intrusion probes in local recognition.
# probetype: 1 = new, 0 = intrusion. Distances for new probes are set to 100.
#wipe everything
rm(list=ls())
library(lme4)
library(gdata)
library(languageR)
filedir <- paste(as.character("C:\\Daten\\R\\Models\\Locrec",sep="\\"))
setwd(filedir)
#for HY Lin's local-recognition experiment summer 2012
#filename <- "MLR.txt"
#for KO's local-recognition experiment in wmc2002 study
filename <- "locrec2002.txt"
Data <- read.table(filename,header=TRUE,row.names=NULL)
Data$spatialexp <- exp(-Data$SpatialDistance)
Data$temporalexp <- exp(-Data$TemporalDistance)
modelrt <- lmer(RT ~ Probetype + spatialexp + temporalexp + (1|pID), data=Data)
# linear regression of RT on probetype, exp(-spatialdistance), exp(-temporaldistance); subject as random factor affecting only the intercept (coded as 1)
modelpc <- lmer(Correctness ~ Probetype + spatialexp + temporalexp + (1|pID), family=binomial, data=Data)
# logistic regression of correctness (type of regression indicated by family)
summary(modelrt)
summary(modelpc)
mcmcrt <- pvals.fnc(modelrt)
# pvals.fnc calculates p values based on MCMC; this works (so far) only for linear regression
meanrt <- tapply(Data$RT, list(Data$SpatialDistance, Data$TemporalDistance), FUN=mean)
mcmcr
mcmcrt
meanrt
help (fun)
meancorr <- tapply(Data$Correctness, list(Data$SpatialDistance, Data$TemporalDistance), FUN=mean)
meancorr
setwd("C:/Daten/R/Plots/Benchmarks.Pub/BM4.1.1.LocalityConstraint")
source(paste(dirname(getwd()), "/functions/Confint.R", sep=""))
source(paste(dirname(getwd()), "/functions/Bakeman.R", sep=""))
spatgrad <- read.table("spatialGradientSerial.txt", header=F)
spatgrad <- spatgrad[,c(1:3,6:10,45:49,50)]
names(spatgrad) <- c("id", "session", "trial", "color1", "color2", "color3", "color4", "color5",
"dist1", "dist2", "dist3", "dist4", "dist5", "response")
selectedIdx <- apply(spatgrad[,c(4:8,14)], MARGIN=1, FUN=function(x){which(as.numeric(x[1:5])==as.numeric(x[6]))}) #which color is equal to the response
spatgrad$selectedIdx <- as.numeric(selectedIdx)
selectedDist <- apply(spatgrad[,c(9:13, 15)], MARGIN=1, FUN=function(x){x[x[6]]}) #which distance is the selected color
spatgrad$selectedDist <- as.numeric(selectedDist)
spatgradError <- subset(spatgrad, selectedDist > 0) #keep only distances > 0 (i.e., errors)
# baseline: draw from the possible errors at random
errorDist <- as.data.frame(t(apply(spatgrad[,c(9:13)], MARGIN=1, FUN=function(x){x[x>0]})))  #keep the 4 distances that are not 0
distSample <- NULL
nSamples <- 100
for (sample in 1:nSamples) {
dsample <- apply(errorDist, MARGIN=1, FUN=function(x){x[sample(1:4,1)]})  # sample from the 4 distances at random -> pick error response at random
distSample <- c(distSample, dsample)
}
nBins <- 6
histbounds <- as.numeric(quantile(distSample, probs=seq(0, 1, 1/nBins))) # histogram bounds selected so that random sampling results in equal frequencies
idvector <- unique(spatgrad$id)
densities <- matrix(NA, length(idvector), nBins)
for (subj in idvector) {
dd <- subset(spatgradError, id==subj)
h <- hist(dd$selectedDist, breaks=histbounds, plot=F)
densities[subj,] <- as.numeric(h$density)
}
Dens <- Confint(Bakeman(densities))
binwidths <- diff(histbounds)
bincenters <- histbounds[1:nBins] + 0.5*binwidths
library("Hmisc")
x11(10,8)
errbar(bincenters, y=Dens[1,], yplus=Dens[2,], yminus=Dens[3,],
xlab="Euclidean Distance", ylab="P(Selection|Error)",
xlim=c(0.5,max(histbounds)+0.5), ylim=c(0,0.3), add=F, type="b", cex=1.3)
xcoord <- cbind(histbounds,histbounds)
ycoord <- cbind(rep(0,nBins+1), rep(0.05,nBins+1))
for (lin in 1:dim(xcoord)[1]) lines(x=xcoord[lin,], y=ycoord[lin,], col="red")
x11(6,5)
errbar(bincenters, y=Dens[1,], yplus=Dens[2,], yminus=Dens[3,],
xlab="Euclidean Distance", ylab="P(Selection|Error)",
xlim=c(0.5,max(histbounds)+0.5), ylim=c(0,0.3), add=F, type="b", cex=1.3)
xcoord <- cbind(histbounds,histbounds)
ycoord <- cbind(rep(0,nBins+1), rep(0.05,nBins+1))
for (lin in 1:dim(xcoord)[1]) lines(x=xcoord[lin,], y=ycoord[lin,], col="red")
